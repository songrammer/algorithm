https://www.acmicpc.net/problem/14891

#### 문제 설명

(전체 문제 설명을 길어서 생략하겠습니다..)

- 다섯째 줄에는 회전 횟수 K(1 ≤ K ≤ 100)가 주어진다.
- 1번 톱니바퀴의 상태, 둘째 줄에 2번 톱니바퀴의 상태, 셋째 줄에 3번 톱니바퀴의 상태, 넷째 줄에 4번 톱니바퀴의 상태가 주어진다.
- 상태는 8개의 정수로 이루어져 있고, 12시방향부터 시계방향 순서대로 주어진다. N극은 0, S극은 1로 나타나있다.
- 총 K번 회전시킨 이후에 네 톱니바퀴의 점수의 합을 출력한다. 점수란 다음과 같이 계산한다.

### 문제 풀이

- hile[cnt][i][j]:k번째의 i번째 톱니 바퀴의 j상태(N or S)
- check[5]:톱니 바퀴가 돌아가는 지 안 돌아가는 지 상태 정보
- K가 100이기때문에 모든 경우의 수를 다 시뮬레이션 해도 O(K _ 4 _ 8) 1초가 안된다.
- 시작할 톱니 바퀴를 기준으로 좌-우를 탐색하며 움직일 지 체크한다.
  - 첫번째 바퀴라면 2~4 순으로 좌우 맞닿은 부분이 다른지 확인 ex. hile[cnt][i][2]!=hile[cnt][i + 1][6]
    - 만일 극이 같다면, 더 이상 회전 할 수 없으니 종료
    - 극이 다르면 check배열에 표시
  - 두번째 바퀴라면 1,2탐색 후 3~4 탐색
    > 이때, (1,2)와 (2,3,4)를 분리해서 생각해야하는데 1,2가 불가능하면 2,3,4를 탐색 안하게 조건 걸어줘서 처음에 틀렸다.
  - 세번째는 (3,4) 탐색후 (3,2,1)순으로 탐색
  - 네번째도 마찬가지
- check 탐색 후에 회전 가능하면, 시작한 점 기준으로 abs(시작점-현재 지점)%2==1이면 다른 방향으로 같다면 같은 방향으로 한칸 씩 회전 해줌
  - 시계방향 회전 시 모두 hile[cnt][i][j] 한 칸씩 위로 밀어서 hile[cnt+1][i][j]에 저장함
  - 반 시계 방향 회전시 hile[cnt][i][j] 한 칸 씩 앞으로 한칸 밀어서 hile[cnt+1][i][j]에 저장함
