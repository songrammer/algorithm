https://www.acmicpc.net/problem/12100

### 문제 풀이

- nx ,ny :다음 좌표
- x,y :현재 좌표
- 모든 경우를 다 돌아볼때 최대 경우가 O(4^5) 이기 때문에 모든 경우를 다 탐색 가능하다.
- 모든 방향으로 이동할 경우를 재귀로 완전 구현 한다.
- 좌표 이동시에는 이동하려는 방향 끝 지점 부터 탐색한다. (ex. -> 일 경우 , N-1열을 기준으로 줄여 나가면서 행을 탐색한다.)
- 해당 하는 좌표가 **숫자** 라면 반복문을 통해 이동
  - 다음 지점이 0일 경우에만 **계속 이동**
  - 다음 지점이 숫자가 같을 경우 합쳐주고 종료 (arr[nx][ny]==arr[ny][ny])
    - 이때, 합친경우에 visited으로 방문처리 해 두번 이상 안 합쳐지게 체킹 후 **종료한다.**
    - 그외 경우 모두 **종료**

> 놓친 점
>
> 1. 합쳐진 이후에는 더 이상 이동을 못하기때문에 break해야한다.
> 2. 모든 좌표를 탐색하는 것이 아닌 '0'이 아닌 좌표만 탐색한다.
> 3. 중간에 풀이를 수정하다가 한번 갔던 방향으로 이동하면 안되는 것으로 잘못 수정함
>
> - 순회 한 뒤에는 합리셋 되기때문에 같은 방향을 이동해도 된다.(변화되어서 합칠 수 있는 값이 존재 해서!)

#### 순서

1. 시작시에 임시 배열을 초기화 해주면서 재귀를 시작한다.

2. 방향에 따라 ,블록을 이동한다.
   - 모든 좌표를 탐색한다.해당 하는 좌표가 **숫자** 라면 종료 될때 까지 반복해서 좌표를 옮긴다.
   - 합쳐 질때마다, 최댓 값을 갱신한다.
3. 5회 반복후 종료한다.
